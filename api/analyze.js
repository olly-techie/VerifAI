// api/analyze.js â€” Vibe Check Backend (Vercel Serverless Function)
// Ported from analyze.php â€” same 6-metric weighted engine

const https = require('https');
const http  = require('http');
const { URL } = require('url');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DICTIONARIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const GENERIC_PHRASES = [
  'leverage','synergy','streamline','scalable','robust','seamless','cutting-edge',
  'state-of-the-art','innovative','comprehensive','holistic','empower','transformative',
  'dynamic','strategic','game-changer','disruptive','bespoke','tailored solutions',
  'best-in-class','world-class','industry-leading','next-generation','end-to-end',
  'value-added','thought leader','paradigm shift','actionable insights','move the needle',
  'bleeding edge','mission-critical','pain points','deep dive','low-hanging fruit',
  'future-proof','lorem ipsum','circle back','bandwidth','boilerplate',
  'boost your','supercharge','revolutionize','harness the power','elevate your',
  'optimize your','maximize your','skyrocket','effortlessly','powerful yet simple',
  'simple yet powerful','say goodbye to','say hello to','meet your new',
  'built for modern','designed for teams','all-in-one','everything you need',
  'loved by thousands','join thousands','join hundreds','trusted by','start for free',
  'free forever','no credit card required','get started today','your dream',
  'the future of','reimagined','reinvented','rethought','ai-powered','powered by ai',
  'built with ai','ai-generated','generated by','crafted by ai','written by ai',
  'chatgpt','beautiful','stunning','delightful','intuitive interface','blazing fast',
  'lightning fast','instant results','one platform','one solution','unlock your potential',
  'take your business to the next level','supercharged','turbocharged',
  'data-driven','results-driven','outcome-focused','customer-centric',
  'best practices','digital transformation','thought leadership','brand awareness',
  'synergize','innovate','disrupt','pivot','agile','ecosystem','omnichannel',
];

const BUILDER_SIGNATURES = {
  'wix.com':'Wix','wixstatic':'Wix','squarespace':'Squarespace',
  'webflow':'Webflow','wordpress':'WordPress','wp-content':'WordPress',
  'wp-includes':'WordPress','shopify':'Shopify','myshopify':'Shopify',
  'weebly':'Weebly','godaddy':'GoDaddy','elementor':'Elementor',
  'et_pb':'Divi','framerusercontent':'Framer','framer.com':'Framer',
  'carrd.co':'Carrd','site123':'Site123','bubble.io':'Bubble',
  'strikingly':'Strikingly','tilda':'Tilda','notion.site':'Notion',
  'super.so':'Super.so','cdn.tailwindcss':'Tailwind CDN',
};

const TW_PREFIXES = [
  'flex','grid','text-','bg-','px-','py-','p-','mx-','my-','mt-','mb-','ml-','mr-',
  'w-','h-','max-w-','min-h-','min-w-','rounded','shadow','border','font-','items-',
  'justify-','gap-','space-','hover:','md:','lg:','sm:','xl:','2xl:','transition',
  'duration-','opacity-','z-','absolute','relative','fixed','overflow','cursor-',
  'col-','row-','self-','place-','inset-','top-','bottom-','left-','right-','ring-',
  'leading-','tracking-','uppercase','lowercase','capitalize','truncate','block',
  'inline','hidden','visible','invisible',
];

const AI_COMMENTS = [
  '<!-- hero','<!-- navigation','<!-- navbar','<!-- features','<!-- benefits',
  '<!-- how it works','<!-- testimonials','<!-- pricing','<!-- cta',
  '<!-- call to action','<!-- footer','<!-- about','<!-- faq','<!-- contact',
  '<!-- stats','<!-- team','<!-- newsletter','<!-- header','<!-- services',
];

const STRUCTURAL_LANDMARKS = {
  hero:         ['id="hero"','class="hero"','<!-- hero'],
  features:     ['id="features"','class="features"','<!-- features'],
  benefits:     ['id="benefits"','class="benefits"','<!-- benefits'],
  'how-it-works':['id="how-it-works"','<!-- how it works'],
  testimonials: ['id="testimonials"','class="testimonials"','<!-- testimonials'],
  pricing:      ['id="pricing"','class="pricing"','<!-- pricing'],
  faq:          ['id="faq"','class="faq"','<!-- faq'],
  cta:          ['id="cta"','class="cta"','<!-- cta','<!-- call to action'],
  team:         ['id="team"','class="team"','<!-- team'],
  stats:        ['id="stats"','class="stats"','<!-- stats'],
  footer:       ['</footer>','<!-- footer'],
};

const VIBE_EMOJIS = ['ğŸš€','âš¡','âœ¨','ğŸ’¡','ğŸ¯','ğŸ”¥','ğŸ’ª','ğŸŒŸ','âœ…','ğŸ‘‰','ğŸ†','ğŸ’','ğŸ¤–','ğŸ‰','â­','ğŸŒˆ','ğŸ’°','ğŸ›¡ï¸','ğŸ”‘','ğŸ“Š','ğŸ“ˆ','ğŸ','ğŸ‘€','ğŸ’«','ğŸ™Œ','âš™ï¸','ğŸ”’','ğŸŒ','ğŸ…','ğŸ¥‡'];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function clamp(v, min = 0, max = 1) { return Math.max(min, Math.min(max, v)); }

function extractText(html) {
  return html
    .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, ' ')
    .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, ' ')
    .replace(/<[^>]+>/g, ' ')
    .replace(/&[a-z]+;/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function getSentences(text, minWords = 4) {
  return text.split(/[.!?]+/)
    .map(s => s.trim())
    .filter(s => s.split(/\s+/).filter(Boolean).length >= minWords);
}

function extractClasses(html) {
  const tokens = [];
  for (const m of html.matchAll(/class=["']([^"']+)["']/g)) {
    for (const cls of m[1].split(/\s+/)) {
      if (cls) tokens.push(cls);
    }
  }
  return tokens;
}

function extractIds(html) {
  return [...html.matchAll(/\bid=["']([^"']+)["']/g)].map(m => m[1]);
}

function shannonEntropy(freqMap) {
  const total = Object.values(freqMap).reduce((a, b) => a + b, 0);
  if (!total) return 0;
  return -Object.values(freqMap).reduce((h, c) => {
    const p = c / total;
    return h + (p > 0 ? p * Math.log2(p) : 0);
  }, 0);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FETCH WITH REDIRECT SUPPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function fetchHtml(rawUrl, redirects = 0) {
  return new Promise((resolve, reject) => {
    if (redirects > 5) return reject(new Error('Too many redirects'));
    let parsed;
    try { parsed = new URL(rawUrl); } catch { return reject(new Error('Invalid URL')); }

    const lib = parsed.protocol === 'https:' ? https : http;
    const req = lib.request({
      hostname: parsed.hostname,
      path: parsed.pathname + parsed.search,
      port: parsed.port || (parsed.protocol === 'https:' ? 443 : 80),
      method: 'GET',
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml',
        'Accept-Encoding': 'identity',
      },
      timeout: 10000,
    }, res => {
      if ([301,302,303,307,308].includes(res.statusCode) && res.headers.location) {
        return resolve(fetchHtml(new URL(res.headers.location, rawUrl).toString(), redirects + 1));
      }
      const chunks = [];
      let size = 0;
      res.on('data', chunk => {
        size += chunk.length;
        chunks.push(chunk);
        if (size > 500000) res.destroy();
      });
      res.on('end', () => resolve(Buffer.concat(chunks).toString('utf8')));
    });
    req.on('error', reject);
    req.on('timeout', () => { req.destroy(); reject(new Error('Request timed out')); });
    req.end();
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// METRIC 1 â€” Generic Phrase Score (25%)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function scoreGenericPhrases(html) {
  const lower = extractText(html).toLowerCase();
  const sentences = getSentences(lower, 4);
  const total = Math.max(sentences.length, 1);
  const hits = []; let count = 0;

  for (const phrase of GENERIC_PHRASES) {
    const idx = lower.indexOf(phrase);
    if (idx !== -1) {
      hits.push(phrase);
      let pos = 0;
      while ((pos = lower.indexOf(phrase, pos)) !== -1) { count++; pos++; }
    }
  }

  const density = count / total;
  const raw = clamp(density / 1.5);
  const uniqueBonus = clamp(hits.length / 50) * 0.15;
  const score = clamp(raw + uniqueBonus);

  let reason = null;
  if (hits.length >= 10)      reason = `${hits.length} generic marketing phrases found ("${hits.slice(0,3).join('", "')}"â€¦) â€” high AI copy density`;
  else if (hits.length >= 4)  reason = `${hits.length} buzzword phrases detected ("${hits.slice(0,2).join('", "')}") â€” typical AI copywriting pattern`;
  else if (hits.length >= 1)  reason = `Minor buzzword usage ("${hits[0]}") â€” weak AI copy signal`;

  return { score: +score.toFixed(4), reason };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// METRIC 2 â€” Repetition / Entropy Score (18%)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function scoreRepetitionEntropy(html) {
  const text    = extractText(html);
  const lower   = text.toLowerCase();
  const classes = extractClasses(html);

  const STOP = new Set(['the','a','an','and','or','but','in','on','at','to','for','of','with','is','are','was','were','be','been','have','has','had','do','does','did','will','would','could','should','may','this','that','these','those','i','you','he','she','it','we','they','not','no','so','as','by','from','your','our','their','its']);
  const words = lower.split(/\W+/).filter(w => w.length > 2 && !STOP.has(w));
  const wordFreq = {};
  for (const w of words) wordFreq[w] = (wordFreq[w] || 0) + 1;
  const wordEntropy = shannonEntropy(wordFreq);
  const wordEntropyScore = clamp(1 - wordEntropy / 10);

  const totalCls  = classes.length;
  const uniqueCls = new Set(classes).size;
  const classRepScore = totalCls > 10 ? clamp((totalCls - uniqueCls) / totalCls / 0.8) : 0;

  const sentences = getSentences(text, 5);
  let varianceScore = 0;
  if (sentences.length >= 8) {
    const lengths = sentences.map(s => s.split(/\s+/).filter(Boolean).length);
    const avg = lengths.reduce((a, b) => a + b, 0) / lengths.length;
    const variance = lengths.reduce((s, l) => s + (l - avg) ** 2, 0) / lengths.length;
    varianceScore = clamp(1 - variance / 80);
  }

  const score = clamp(wordEntropyScore * 0.40 + classRepScore * 0.40 + varianceScore * 0.20);

  let reason = null;
  if (score > 0.65)      reason = `Low content entropy (word entropy: ${wordEntropy.toFixed(1)} bits, class repetition: ${Math.round(classRepScore * 80)}%) â€” highly repetitive, typical of AI output`;
  else if (score > 0.40) reason = `Moderate repetition detected (word entropy: ${wordEntropy.toFixed(1)} bits) â€” signs of templated content`;
  else if (score < 0.20) reason = `High content entropy (${wordEntropy.toFixed(1)} bits) and varied sentence structure â€” natural, organic writing`;

  return { score: +score.toFixed(4), reason };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// METRIC 3 â€” Structural Pattern Score (13%)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function scoreStructuralPattern(html) {
  const lower = html.toLowerCase();
  const foundLandmarks = {};

  for (const [name, patterns] of Object.entries(STRUCTURAL_LANDMARKS)) {
    for (const p of patterns) {
      const pos = lower.indexOf(p.toLowerCase());
      if (pos !== -1 && (foundLandmarks[name] === undefined || pos < foundLandmarks[name])) {
        foundLandmarks[name] = pos;
      }
    }
  }

  const detected = Object.entries(foundLandmarks).sort((a, b) => a[1] - b[1]).map(e => e[0]);
  const coverageScore = clamp(detected.length / 7);

  const canonical = ['hero','features','benefits','how-it-works','testimonials','pricing','faq','cta','team','stats','footer'];
  let orderScore = 0;
  if (detected.length >= 3) {
    const positions = canonical.map(s => detected.indexOf(s)).filter(i => i !== -1);
    let ordered = 0;
    for (let i = 0; i < positions.length - 1; i++) if (positions[i] < positions[i+1]) ordered++;
    orderScore = clamp(ordered / Math.max(positions.length - 1, 1));
  }

  let commentHits = 0;
  for (const c of AI_COMMENTS) if (lower.includes(c)) commentHits++;
  const commentScore = clamp(commentHits / 6);

  const score = clamp(coverageScore * 0.45 + orderScore * 0.30 + commentScore * 0.25);

  let reason = null;
  if (score > 0.65)           reason = `${detected.length} cookie-cutter landing page sections in canonical AI order (${detected.slice(0,5).join(' â†’ ')}â€¦) â€” textbook AI site template`;
  else if (score > 0.35)      reason = `${detected.length} standard page sections found (${detected.slice(0,4).join(', ')}) â€” structured like an AI-generated layout`;
  else if (detected.length > 0) reason = 'Irregular section structure â€” does not match common AI landing page templates';

  return { score: +score.toFixed(4), reason };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// METRIC 4 â€” Metadata / Fingerprint Score (23%)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function scoreMetadataFingerprint(html) {
  const lower = html.toLowerCase();
  let points = 0;
  const signals = [];

  // meta generator
  const genMatch = html.match(/<meta[^>]+name=["']generator["'][^>]*content=["']([^"']+)["'][^>]*>/i)
    || html.match(/<meta[^>]+content=["']([^"']+)["'][^>]*name=["']generator["'][^>]*>/i);
  if (genMatch) { points += 0.45; signals.push(`Meta generator: "${genMatch[1].trim()}"`); }

  // Builder signatures
  const detected = [];
  for (const [sig, label] of Object.entries(BUILDER_SIGNATURES)) {
    if (lower.includes(sig) && !detected.includes(label)) detected.push(label);
  }
  if (detected.length) { points += Math.min(detected.length * 0.20, 0.40); signals.push(`Builder/CMS: ${detected.join(', ')}`); }

  // Tailwind CDN
  if (['cdn.tailwindcss.com','unpkg.com/tailwindcss'].some(p => lower.includes(p))) {
    points += 0.25; signals.push('Tailwind CSS CDN â€” characteristic of AI prototypes');
  }

  // AI attribution text
  const aiAttrib = ['built with ai','powered by ai','generated by chatgpt','made with chatgpt','built by ai','written by ai'];
  if (aiAttrib.some(a => lower.includes(a))) { points += 0.35; signals.push('Explicit AI attribution in page text'); }

  // Heavy Tailwind ratio
  const classes = extractClasses(html);
  const twCount = classes.filter(c => TW_PREFIXES.some(p => c.startsWith(p))).length;
  const twRatio = classes.length > 10 ? twCount / classes.length : 0;
  let longStack = 0;
  for (const m of html.matchAll(/class=["']([^"']+)["']/g)) {
    if (m[1].split(/\s+/).filter(Boolean).length >= 8) longStack++;
  }
  if (twRatio > 0.55 || longStack >= 8) {
    points += clamp(twRatio / 0.80) * 0.25;
    signals.push(`Heavy Tailwind utility usage (${Math.round(twRatio * 100)}% of classes, ${longStack} elements with 8+ stacked utilities)`);
  }

  // Script tag volume
  const scriptCount = (html.match(/<script\b[^>]*>/gi) || []).length;
  if (scriptCount > 25) { points += 0.10; signals.push(`${scriptCount} script tags â€” heavy JS injection`); }

  const score = clamp(points);

  let reason = null;
  if (score > 0.65)      reason = `Strong builder/AI fingerprint: ${signals.slice(0,2).join('; ')}`;
  else if (score > 0.30) reason = `Builder/tool signatures detected: ${signals.slice(0,2).join('; ')}`;
  else if (signals.length) reason = `Minor fingerprint signal: ${signals[0]}`;

  return { score: +score.toFixed(4), reason };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// METRIC 5 â€” Naming Randomness Score (7%, inverted)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function scoreNamingRandomness(html) {
  const tokens = [...extractClasses(html), ...extractIds(html)];
  if (tokens.length < 8) return { score: 0.5, reason: null };

  const lengths = tokens.map(t => t.length);
  const avgLen = lengths.reduce((a, b) => a + b, 0) / lengths.length;
  const variance = lengths.reduce((s, l) => s + (l - avgLen) ** 2, 0) / lengths.length;

  const hasBEM    = tokens.filter(t => /^[a-z]+(__[a-z]+)?(--[a-z]+)?$/.test(t)).length / tokens.length;
  const hasCamel  = tokens.filter(t => /[a-z][A-Z]/.test(t)).length / tokens.length;
  const hasSnake  = tokens.filter(t => t.includes('_')).length / tokens.length;
  const hasAbbrev = tokens.filter(t => /^[a-z]{1,3}(-[a-z]{1,3}){1,3}$/.test(t)).length / tokens.length;
  const conventionMix = Math.min(hasBEM + hasCamel + hasSnake + hasAbbrev, 1);

  const uniqueRatio = new Set(tokens).size / tokens.length;
  const varScore    = clamp(variance / 30);
  const randomness  = clamp(conventionMix * 0.35 + uniqueRatio * 0.40 + varScore * 0.25);

  let reason = null;
  if (randomness > 0.70)      reason = `Diverse, inconsistent CSS naming (${Math.round(uniqueRatio*100)}% unique tokens, mixed conventions) â€” strongly suggests hand-coded styles`;
  else if (randomness < 0.25) reason = `Highly uniform CSS naming (${Math.round(uniqueRatio*100)}% unique tokens, avg length ${avgLen.toFixed(1)}) â€” consistent with AI-generated classes`;

  return { score: +randomness.toFixed(4), reason };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// METRIC 6 â€” Emoji Density Score (14%)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function scoreEmojiDensity(html) {
  const emojiRx = /[\u{1F000}-\u{1FFFF}\u{2600}-\u{27BF}\u{2300}-\u{23FF}\u{2B00}-\u{2BFF}]/gu;

  const plainText   = extractText(html);
  const allEmojis   = plainText.match(emojiRx) || [];
  const totalEmojis = allEmojis.length;
  const uniqueEmojis = new Set(allEmojis).size;
  const sentences   = getSentences(plainText, 3);
  const sentenceCount = Math.max(sentences.length, 1);

  const densityRatio = totalEmojis / sentenceCount;
  const densityScore = clamp(densityRatio / 3);

  // Headings with emoji
  const headingBlocks = [...html.matchAll(/<h[1-6][^>]*>([\s\S]*?)<\/h[1-6]>/gi)];
  let headingsWithEmoji = 0;
  for (const m of headingBlocks) {
    if (emojiRx.test(m[1].replace(/<[^>]+>/g, ''))) { headingsWithEmoji++; emojiRx.lastIndex = 0; }
  }
  const headingScore = headingBlocks.length > 0 ? clamp(headingsWithEmoji / headingBlocks.length / 0.5) : 0;

  // <li> items with emoji at start
  const listItems = [...html.matchAll(/<li[^>]*>([\s\S]*?)<\/li>/gi)];
  let lisWithEmoji = 0;
  for (const m of listItems) {
    const stripped = m[1].replace(/<[^>]+>/g, '').trim();
    if (emojiRx.test(stripped.charAt(0))) { lisWithEmoji++; emojiRx.lastIndex = 0; }
  }
  const liScore = listItems.length > 3 ? clamp(lisWithEmoji / listItems.length / 0.6) : 0;

  const repetitionScore = totalEmojis >= 4 && uniqueEmojis > 0
    ? clamp((1 - uniqueEmojis / totalEmojis) / 0.7)
    : 0;

  const vibeHits = VIBE_EMOJIS.filter(e => plainText.includes(e)).length;
  const vibeScore = clamp(vibeHits / 8);

  const score = clamp(
    densityScore * 0.25 + headingScore * 0.30 +
    liScore * 0.15 + repetitionScore * 0.15 + vibeScore * 0.15
  );

  let reason = null;
  if (totalEmojis === 0) {
    reason = null;
  } else if (score > 0.65) {
    const sampleVibes = VIBE_EMOJIS.filter(e => plainText.includes(e)).slice(0, 5).join(' ');
    reason = `${totalEmojis} emojis (${uniqueEmojis} unique) â€” heavy emoji decoration in headings & bullets (${sampleVibes}) is a hallmark of vibe-coded sites`;
  } else if (score > 0.35) {
    reason = `${totalEmojis} emojis across the page (${headingsWithEmoji} in headings) â€” moderate emoji styling typical of AI-generated content`;
  }

  return { score: +score.toFixed(4), reason, totalEmojis };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WEIGHTED COMBINER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function combineMetrics(m1, m2, m3, m4, m5, m6) {
  const weights = { genericity: 0.25, entropy: 0.18, structure: 0.13, metadata: 0.23, naming: 0.07, emoji: 0.14 };
  const scores  = {
    genericity: m1.score,
    entropy:    m2.score,
    structure:  m3.score,
    metadata:   m4.score,
    naming:     1 - m5.score,   // inverted
    emoji:      m6.score,
  };

  const weighted = Object.entries(weights).reduce((sum, [k, w]) => sum + scores[k] * w, 0);
  const finalScore = Math.round(clamp(weighted) * 100);

  const allReasons = [m4.reason, m6.reason, m1.reason, m3.reason, m2.reason, m5.reason].filter(Boolean);
  const reasons = allReasons.length
    ? allReasons.slice(0, 3)
    : [finalScore < 35 ? 'No significant AI fingerprints â€” content appears organically written' : 'Multiple signals collectively suggest AI-generated content'];

  return {
    score:   finalScore,
    verdict: finalScore >= 45 ? 'Likely AI' : 'Likely Human',
    reasons,
    metricBreakdown: {
      genericity: Math.round(scores.genericity * 100),
      entropy:    Math.round(scores.entropy    * 100),
      structure:  Math.round(scores.structure  * 100),
      metadata:   Math.round(scores.metadata   * 100),
      naming:     Math.round((1 - m5.score)    * 100),
      emoji:      Math.round(scores.emoji      * 100),
    },
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VERCEL HANDLER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
module.exports = async (req, res) => {
  // CORS
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') return res.status(200).end();
  if (req.method !== 'POST')   return res.status(405).json({ error: 'Method not allowed' });

  let body = '';
  await new Promise(r => { req.on('data', d => body += d); req.on('end', r); });

  let rawUrl;
  try { rawUrl = JSON.parse(body).url?.trim(); } catch { return res.status(400).json({ error: 'Invalid JSON' }); }
  if (!rawUrl) return res.status(400).json({ error: 'No URL provided' });
  if (!/^https?:\/\//i.test(rawUrl)) rawUrl = 'https://' + rawUrl;

  try { new URL(rawUrl); } catch { return res.status(400).json({ error: 'Invalid URL' }); }

  // Block private IPs
  const host = new URL(rawUrl).hostname;
  if (/^(localhost|127\.|10\.|192\.168\.|172\.(1[6-9]|2\d|3[01])\.)/.test(host)) {
    return res.status(403).json({ error: 'Private IP not allowed' });
  }

  try {
    const html = await fetchHtml(rawUrl);
    const m1 = scoreGenericPhrases(html);
    const m2 = scoreRepetitionEntropy(html);
    const m3 = scoreStructuralPattern(html);
    const m4 = scoreMetadataFingerprint(html);
    const m5 = scoreNamingRandomness(html);
    const m6 = scoreEmojiDensity(html);
    const result = combineMetrics(m1, m2, m3, m4, m5, m6);
    return res.status(200).json(result);
  } catch (e) {
    return res.status(422).json({ error: e.message || 'Fetch failed' });
  }
};
